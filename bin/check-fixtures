#!/usr/bin/env php
<?php

/**
 * Validate that visual test fixtures are in sync between terminals.
 *
 * Checks that:
 * 1. Every iTerm fixture has a corresponding Ghostty fixture (and vice versa)
 * 2. Matching fixtures have identical content
 *
 * Usage:
 *   composer test:fixtures    Check fixture sync status
 */

$fixturesDir = __DIR__ . '/../tests/Fixtures';
$errors = [];
$checked = 0;

echo "Checking terminal fixture synchronization...\n\n";

// Check screenshot fixtures (tests/Fixtures/{iterm,ghostty}/...)
$checked += checkFixtureDirectory(
    $fixturesDir . '/iterm',
    $fixturesDir . '/ghostty',
    'iterm',
    'ghostty',
    $errors
);

// Check render fixtures (tests/Fixtures/Renders/{iterm,ghostty}/...)
$checked += checkFixtureDirectory(
    $fixturesDir . '/Renders/iterm',
    $fixturesDir . '/Renders/ghostty',
    'iterm',
    'ghostty',
    $errors
);

if (count($errors) > 0) {
    echo "ERRORS FOUND:\n\n";
    foreach ($errors as $error) {
        echo "  ✗ {$error}\n";
    }
    echo "\n";
    echo "Found " . count($errors) . " fixture validation error(s).\n";
    echo "All visual tests must be run in both iTerm and Ghostty.\n";
    echo "Fixtures must produce identical output in both terminals.\n";
    exit(1);
}

if ($checked === 0) {
    echo "No terminal-specific fixtures found to validate.\n";
} else {
    echo "✓ All {$checked} fixture pair(s) validated successfully.\n";
}

exit(0);

/**
 * Check fixtures in a directory pair (e.g., iterm vs ghostty).
 *
 * @return int Number of fixture pairs checked
 */
function checkFixtureDirectory(
    string $dir1,
    string $dir2,
    string $name1,
    string $name2,
    array &$errors
): int {
    $checked = 0;

    // Check dir1 -> dir2
    if (is_dir($dir1)) {
        $files = findJsonFiles($dir1);
        foreach ($files as $file) {
            $relPath = substr($file, strlen($dir1) + 1);
            $otherFile = $dir2 . '/' . $relPath;

            if (!file_exists($otherFile)) {
                $errors[] = "Missing {$name2} fixture for: {$relPath}";
            } elseif (!filesMatch($file, $otherFile)) {
                $errors[] = "Fixture mismatch between terminals for: {$relPath}";
            } else {
                $checked++;
            }
        }
    }

    // Check dir2 -> dir1 (only for missing files, matches already checked)
    if (is_dir($dir2)) {
        $files = findJsonFiles($dir2);
        foreach ($files as $file) {
            $relPath = substr($file, strlen($dir2) + 1);
            $otherFile = $dir1 . '/' . $relPath;

            if (!file_exists($otherFile)) {
                $errors[] = "Missing {$name1} fixture for: {$relPath}";
            }
        }
    }

    return $checked;
}

/**
 * Recursively find all JSON files in a directory.
 */
function findJsonFiles(string $dir): array
{
    $files = [];

    if (!is_dir($dir)) {
        return $files;
    }

    $iterator = new RecursiveIteratorIterator(
        new RecursiveDirectoryIterator($dir, RecursiveDirectoryIterator::SKIP_DOTS)
    );

    foreach ($iterator as $file) {
        if ($file->isFile() && $file->getExtension() === 'json') {
            $files[] = $file->getPathname();
        }
    }

    return $files;
}

/**
 * Check if two files have identical content.
 */
function filesMatch(string $file1, string $file2): bool
{
    return file_get_contents($file1) === file_get_contents($file2);
}
